set nocompatible
filetype off

packadd minpac
call minpac#init()
call minpac#add('k-takata/minpac', {'type':'opt'})
call minpac#add('tpope/vim-surround')
call minpac#add('tpope/vim-unimpaired')
call minpac#add('itchyny/lightline.vim')
call minpac#add('Townk/vim-autoclose')
call minpac#add('tpope/vim-fugitive')
call minpac#add('tpope/vim-endwise')
call minpac#add('tpope/vim-surround')
call minpac#add('tpope/vim-commentary')
call minpac#add('tpope/vim-repeat')
call minpac#add('ntpeters/vim-better-whitespace')
call minpac#add('vim-scripts/taglist.vim')
call minpac#add('kana/vim-textobj-user')
call minpac#add('nelstrom/vim-textobj-rubyblock')
call minpac#add('rking/ag.vim')
call minpac#add('janko-m/vim-test')
call minpac#add('SirVer/ultisnips')
call minpac#add('honza/vim-snippets')
call minpac#add('christoomey/vim-tmux-navigator')
call minpac#add('w0rp/ale')
call minpac#add('sheerun/vim-polyglot')
call minpac#add('machakann/vim-highlightedyank')
call minpac#add('jlanzarotta/bufexplorer')
call minpac#add('slashmili/alchemist.vim')
call minpac#add('airblade/vim-gitgutter')
call minpac#add('junegunn/fzf.vim')

command! PackUpdate call minpac#update()
command! PackClean  call minpac#clean()

filetype plugin indent on
runtime macros/matchit.vim

set runtimepath+=~/.vim,~/.vim/after,/usr/local/opt/fzf

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" BASIC EDITING CONFIGURATION
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set si
set shell=/bin/sh
set clipboard=unnamed
set novisualbell
set autoread
set hidden
set nowrap
set winwidth=80
set colorcolumn=81
set history=10000
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set autoindent
set laststatus=2
set showmatch
set incsearch
set hlsearch
set number
set nobackup
set nowb
set noswapfile
set linebreak
set ignorecase smartcase
set magic
" Using these causes scrolling slowdown in vim8
" set cursorline
" set cursorcolumn
set cmdheight=2
set switchbuf=useopen
set numberwidth=4
set showtabline=2
set t_ti= t_te=
set scrolloff=3
set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backspace=indent,eol,start
set showcmd
syntax on
filetype plugin indent on
set wildmode=longest,list
set wildmenu
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*_build*

let mapleader=","

nnoremap <Leader>w :w<CR>
inoremap <C-w> <Esc>:w<CR>
vnoremap <Leader>w <Esc>:w<CR>

map <leader>f :Files<cr>
map <leader>b :Buffers<cr>
map <leader>c :Tags<cr>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" COLOR
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
:set t_Co=256 " 256 colors
:set background=dark
:color railscasts

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" MISC KEY MAPS
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Move around splits with <c-hjkl>
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l

" close the quick fix window
nnoremap ;; :cclose<CR>

" use either key combo to leave mode
inoremap kj <esc>:w<CR>
inoremap jk <esc>:w<CR>

" Clear the search buffer when hitting return
function! MapCR()
  nnoremap <space> :nohlsearch<cr>
endfunction
call MapCR()

" OPEN FILES IN DIRECTORY OF CURRENT FILE
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>e :edit %%
map <leader>v :view %%

" Strip whitespace on buffer write using the better-whitespace plugin
autocmd BufWritePre * StripWhitespace
let g:better_whitespace_filetypes_blacklist=['md', 'markdown']

" In insert mode, cursor is a pipe. In normal mode, a block
let &t_SI = "\<Esc>]50;CursorShape=1\x7"
let &t_EI = "\<Esc>]50;CursorShape=0\x7"

:hi ColorColumn guibg=#2d2d2d ctermbg=229 ctermfg=236
:hi CursorColumn guibg=#2d2d2d ctermbg=234

" using vroom to run tests, do not clear the screen before the run
let g:vroom_clear_screen=0

" This is used to remove accents from the YouTube adjustment reports so they
" process through the SIP system correctly.
:map <F3> :%s/.*/\=tr(submatch(0), 'óèâìÎ·²ïæçùãÿøþò¿ü¨êÜë´öäáàôåíúéàñÑÏÉÍÀÈÁÞØÚß','oeaii__iacuayopo_u_eUe_oaaaoaiueanNIE__IAEA_O_U____s')

" Map up and down arrow keys to move lines and visual selections in
" normal, insert and visual modes
nnoremap <Up> :m .-2<CR>==
nnoremap <Down> :m .+1<CR>==
inoremap <Up> <Esc>:m .-2<CR>==gi
inoremap <Down> <Esc>:m .+1<CR>==gi
vnoremap <Up> :m '<-2<CR>gv=gv''
vnoremap <Down> :m '>+1<CR>gv=gv
" Move characters left/right using the arrow keys
nnoremap <Right> xp
nnoremap <Left> Xph

" with out this, editing crontabs fails on some machines
autocmd filetype crontab setlocal nobackup nowritebackup

" Map whole line completion to a single key
inoremap <C-l> <C-x><C-l>

" vim-test mappings & configuration
nmap <silent> <leader>R :TestNearest<CR>
nmap <silent> <leader>r :TestFile<CR>
nmap <silent> <leader>t :TestFile<CR>
nmap <silent> <leader>a :TestSuite<CR>
nmap <silent> <leader>l :TestLast<CR>
nmap <silent> <leader>g :TestVisit<CR>

" Ultisnips configuration.
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

" Edit and source the .vimrc easily
nmap <leader>vr :vsp $MYVIMRC<cr>
nmap <leader>so :source $MYVIMRC<cr>

" Always vertically split diff windows
set diffopt+=vertical

" Go to the start of the first word in a line
nmap 0 ^

" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

augroup vimrcEx
  " Clear all autocmds in the group
  autocmd!
  autocmd FileType text setlocal textwidth=78
  " Jump to last cursor position unless it's invalid or in an event handler
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

  "for ruby, autoindent with two spaces, always expand tabs
  autocmd FileType ruby,haml,eruby,yaml,html,javascript,sass,cucumber,css set ai sw=2 sts=2 et
  autocmd FileType python set sw=4 sts=4 et

  autocmd! BufRead,BufNewFile *.sass setfiletype sass

  autocmd BufRead *.mkd  set ai formatoptions=tcroqn2 comments=n:&gt;
  autocmd BufRead *.markdown  set ai formatoptions=tcroqn2 comments=n:&gt;
  " Don't syntax highlight markdown because it's often wrong
  autocmd! FileType mkd setlocal syn=off
  autocmd! FileType markdown setlocal syn=off

" Leave the return key alone when in command line windows, since it's used
  " to run commands there.
  autocmd! CmdwinEnter * :unmap <cr>
  autocmd! CmdwinLeave * :call MapCR()
augroup END

" Make it easy to get to ag
nnoremap \ :Ag<SPACE>

" Use ag for vim's grep
set grepprg=ag\ --nogroup\ --nocolor

" use ag to search the current project to find all
" occurrences of the word under the cursor
nnoremap K :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

map y <Plug>(highlightedyank)

" Lightline configuration
let g:lightline = {
\ 'colorscheme': 'one',
\ 'active': {
\   'left': [['mode', 'paste'], ['filename', 'modified']],
\   'right': [['lineinfo'], ['percent'], ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok']]
\ },
\ 'component_expand': {
\   'linter_warnings': 'LightlineLinterWarnings',
\   'linter_errors': 'LightlineLinterErrors',
\   'linter_ok': 'LightlineLinterOK'
\ },
\ 'component_type': {
\   'readonly': 'error',
\   'linter_warnings': 'warning',
\   'linter_errors': 'error'
\ },
\ }

function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction

function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '✓ ' : ''
endfunction

function! s:MaybeUpdateLightline()
  if exists('#lightline')
    call lightline#update()
  end
endfunction

autocmd User ALELint call s:MaybeUpdateLightline()
